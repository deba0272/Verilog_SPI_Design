Code:
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 17.09.2024 00:32:02
// Design Name: 
// Module Name: spi
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module spi(
input clk,start,rst,
input [11:0]din,
output reg cs,mosi,done,
output sclk);
integer count=0;
reg sclkt=0;
parameter Divisor=20;
always@(posedge clk or posedge rst)//added reset signal for controlling the start  from an unknown state
if(rst)
begin
count<=0;
sclkt<=0;
end
else
begin
if(count<(Divisor/2))//here 10 cycles and then toggle used parameter to control divider dynamically
count<=count+1;
else
begin
count<=0;
sclkt<=~sclkt;
end
end

parameter idle=0,start_tx=1,send=2,end_tx=3;
reg [1:0] state=idle;
reg [11:0]temp;
integer bitcount=0;

always@(posedge sclkt)
begin
case(state)
idle:
begin
mosi<=1'b0;
cs<=1'b1;
done<=1'b0;
if(start==1'b1)
state<=start_tx;
else
state<=idle;
end

start_tx:
begin
cs<=1'b0;
temp<=din;
state<=send;
end

send:
begin
if(bitcount<=11)
begin
bitcount<=bitcount+1;
mosi<=temp[bitcount];
state<=send;
end
else
begin
bitcount<=0;
state<=end_tx;
mosi<=0;
end
end

end_tx:
begin
cs<=1'b1;
state<=idle;
done<=1'b1;
end
default:
state<=idle;
endcase
end
assign sclk=sclkt;
endmodule




TestBench:
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 17.09.2024 02:01:03
// Design Name: 
// Module Name: spi_tb
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module spi_tb();
reg clk;
reg start;
reg [11:0]din;
wire cs;
wire mosi;
wire done;
wire sclk;

spi uut(.clk(clk),
.start(start),
.din(din),
.cs(cs),
.mosi(mosi),
.done(done),
.sclk(sclk)
);
//clock generator
initial begin
clk=0;
forever #5 clk=~clk;
end


initial begin
start=0;
din=12'b000000000000;
#100;

$display("case 1:Transmission of data 1");
din=12'b101010101010;
start=1;
#10;
start=0;

fork
begin
while(done==0)
begin
#10;
end
$display("transmission time: %t",$time);
end
join

$display("case 2:Transmission of second data");
din=12'b111111111111;
start=1;
#10;
start=0;

fork
begin
while(done==0)
begin
#10;
end
$display("transmission time: %t",$time);
end
join

$display("case 3:Transmission of 3rd data");
din=12'b000000000000;
start=1;
#10;
start=0;

fork
begin
while(done==0)
begin
#10;
end
$display("transmission time: %t",$time);
end
join

$display("case 4:TRansmission data this case is basically to determine that the transmission won't get affected with the current transmission");
din=12'b101010101010;
start=1;
#10;
start=0;
#20;
start=1;
#10;
start=0;

fork
begin
while(done==0)
begin
#10;
end
$display("transmission time: %t",$time);
end
join
$stop;
end

initial begin
$monitor("Time=%0t | clk=%b | start=%b | din=%b |cs=%b | mosi=%b |sclk=%b | done=%b",
$time,clk,start,din,cs,mosi,sclk,done);
end
endmodule
